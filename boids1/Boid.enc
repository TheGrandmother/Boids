passive class BoidData {
  location: Vector2D
  velocity: Vector2D
  acceleration: Vector2D
  r: real
  maxforce: real -- Maximum steering force
  maxspeed: real -- Maximum speed

  def init(loc: Vector2D): void {
    this.location = loc;
    this.acceleration = new Vector2D(0.0, 0.0);
    let angle = randomReal(0, 6.28);
    this.velocity = new Vector2D(cos(angle)*1, sin(angle)*1);
    this.r = 2.0;
    this.maxspeed = 2.0;
    this.maxforce = 0.03;
  }

  def clone(): BoidData {
    let res = new BoidData(this.location.clone());
    res.velocity = this.velocity.clone();
    res.acceleration = this.acceleration.clone();
    res.r = this.r;
    res.maxforce = this.maxforce;
    res.maxspeed = this.maxspeed;
    res
  }

  def show(id: int) : void {
    print("{},{},{},{},{}\n",
          id,
          this.location.x, this.location.y,
          this.velocity.x, this.velocity.y)
  }
}

class Boid {
  id: int
  --data: BoidData
  width: int
  height: int

  def init(id: int,  width: int, height: int): void {
    this.id = id;
    --this.data = bd;
    this.width = width;
    this.height = height;
  }

  def move(flock : Flock, boids: [BoidData]): void {
    -- the BoidData for the result
    let sendable = (boids[this.id]).clone();
    -- calculation
    let sep = this.separation(boids);
    let ali = this.align(boids);
    let coh = this.cohesion(boids);
    -- Arbitrarily weight these forces
    let weightedSep = sep.mul(1.0);
    let weightedAli = ali.mul(7.0);
    let weightedCoh = coh.mul(1.5);
    -- Add the force vectors to acceleration
    sendable.acceleration = sendable.acceleration.add(weightedSep).
                              add(weightedAli).
                              add(weightedCoh);
    -- Update velocity
    sendable.velocity = sendable.velocity.add(sendable.acceleration).
                          limit(sendable.maxspeed); -- Limit speed

    sendable.location = sendable.location.add(sendable.velocity);

    -- Reset accelertion to 0 each cycle
    sendable.acceleration = sendable.acceleration.mul(0);

    this.borders(boids,sendable);

    sendable.show(this.id);
    flock!ack(sendable, this.id);
  }

  def separation(boids: [BoidData]): Vector2D {
    let desiredSeparation = 25.0;
    let steer = new Vector2D(0.0, 0.0);
    let count = 0;

    -- For every boid in the system, check if it's too close
    for other in boids {
      let dist = (boids[this.id]).location.distance(other.location);
      if (dist > 0) and (dist < desiredSeparation) then {
        let diff = (boids[this.id]).location.sub(other.location);
        let normalizedDiff = diff.normalize().div(dist);
        steer = steer.add(normalizedDiff);
        count = count + 1
      }
    };
    if (count > 0) then
      steer = steer.div(count);
    if steer.magnitude() > 0 then {
      steer.normalize().
        mul((boids[this.id]).maxspeed).
        sub((boids[this.id]).velocity).
        limit((boids[this.id]).maxforce)
    } else {
      steer
    }
  }

  def seek(boids: [BoidData], target: Vector2D): Vector2D{
    let desired = target.sub((boids[this.id]).location);
    let normalizedDesired = desired.normalize().mul((boids[this.id]).maxspeed);
    normalizedDesired.sub((boids[this.id]).velocity).limit((boids[this.id]).maxforce);
  }
  -- Alignment
  -- For every nearby boid in the system, calculate the average velocity
  def align (boids: [BoidData]) : Vector2D {
    let neighbordist = 100;
    let sum = new Vector2D(0.0, 0.0);
    let count = 0;
    for other in boids {
      let d = sum.distance(other.location);
      if (d > 0) and (d < neighbordist) then {
        sum = sum.add(other.velocity);
        count = count + 1;
      }
    };
    if (count > 0) then {
      sum.div(count*1.0).
        normalize().
        mul((boids[this.id]).maxspeed).
        sub((boids[this.id]).velocity).
        limit((boids[this.id]).maxforce);
    }
    else {
      new Vector2D(0.0, 0.0);
    }
  }

  def cohesion(boids: [BoidData]) : Vector2D {
    let neighborDistance = 50.0;
    let location = (boids[this.id]).location;
    let sum = new Vector2D(0.0, 0.0);
    let count = 0;
    for other in boids {
      let d = location.distance(other.location);
      if (d > 0) and (d < neighborDistance) then {
        sum = sum.add(other.location);
        count = count + 1;
      }
    };
    if (count > 0) then {
      this.seek(boids,sum.div(count));
    } else {
      new Vector2D(0, 0);
    }
  }

  def borders(boids: [BoidData], sendable: BoidData): void {
    let x = sendable.location.x;
    let y = sendable.location.y;
    if x < (0-(boids[this.id]).r) then {
      x = this.width + (boids[this.id]).r;
    } else if x > this.width + (boids[this.id]).r then {
      x = 0-(boids[this.id]).r;
    };

    if y < (0-(boids[this.id]).r) then {
      y = this.height + (boids[this.id]).r;
    } else if y > (this.height+(boids[this.id]).r) then {
      y = 0-(boids[this.id]).r;
    };

    sendable.location = new Vector2D(x, y);
  }
}

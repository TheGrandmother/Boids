import Random
-- import Util -- commented to avoid duplicate inclusion
import Vectors

class Main {

  def main(args: [String]): void {
    setSeed(1);
    print("Hi! {}\n", |args|);
    print("RandomReal is {}\n", randomReal(0, 10));
    print("RandomReal is {}\n", randomReal(0, 10));
    print("RandomReal is {}\n", randomReal(0, 10));
    print("RandomReal is {}\n", randomReal(0, 10));
  }
}

passive class BoidData {
  location: Vector2D
  velocity: Vector2D
  acceleration: Vector2D
  r: real
  maxforce: real -- Maximum steering force
  maxspeed: real -- Maximum speed

  def init(loc: Vector2D): void {
    this.location = loc;
    this.acceleration = new Vector2D(0.0, 0.0);

    let angle = random(6.28) ; -- ?
    this.velocity = new Vector2D(cos(angle), sin(angle));
    this.r = 2.0;
    this.maxspeed = 2.0;
    this.maxforce = 0.03;
  }

  def separation(boids: [Boid]): void {
    let desiredseparation = 25.0;
    let steer = new Vector2D( 0.0, 0.0);
    let count = 0;

    -- for boid in voids {
    --   ()
    -- }


    -- For every boid in the system, check if it's too close

    -- for (Boid other : boids) {
    --   float d = PVector.dist(location, other.location);
    --   // If the distance is greater than 0 and less than an arbitrary amount (0 when you are yourself)
    --   if ((d > 0) && (d < desiredseparation)) {
    --     // Calculate vector pointing away from neighbor
    --     PVector diff = PVector.sub(location, other.location);
    --     diff.normalize();
    --     diff.div(d);        // Weight by distance
    --     steer.add(diff);
    --     count++;            // Keep track of how many
    --   }
    -- }
    -- // Average -- divide by how many
    -- if (count > 0) {
    --   steer.div((float)count);
    -- }
    --
    -- // As long as the vector is greater than 0
    -- if (steer.mag() > 0) {
    --   // First two lines of code below could be condensed with new PVector setMag() method
    --   // Not using this method until Processing.js catches up
    --   // steer.setMag(maxspeed);
    --
    --   // Implement Reynolds: Steering = Desired - Velocity
    --   steer.normalize();
    --   steer.mult(maxspeed);
    --   steer.sub(velocity);
    --   steer.limit(maxforce);
    -- }
    -- return steer
  }

}


class Boid {
  id: int
  data: BoidData

  def init(id: int, loc: Vector2D): void {
    this.id = id;
    this.data = new BoidData(loc);
  }

  def move(boids: [BoidData]): void {
    ()
  }

  def separation(boids: [BoidData]): void {
    let desiredseparation = 25.0;
    let steer = new Vector2D(0.0, 0.0);
    let count = 0;

    -- For every boid in the system, check if it's too close
    for other in boids {
      let dist = this.data.location.distance(other.location);
        if (dist > 0) and (dist < desiredseparation) then {
          let diff = this.data.location.sub(other.location);
          diff.normalize();
          diff.div(dist);
          steer.add(diff);
          count = count + 1
        }
    };
    if (count > 0) then steer.div(count);
    if steer.magnitude() > 0 then {
      steer.normalize();
      steer.mul(this.data.maxspeed);
      steer.sub(this.data.velocity);
      steer.limit(this.data.maxforce)
    };
    steer
  }

def seek(target: Vector2D): Vector2D{
     let desired = target.sub(this.data.location);
     desired.normalize();
     desired.mul(this.data.maxspeed);

     let steer = desired.sub(this.data.velocity);
     steer.limit(this.data.maxforce);

     steer;
   }

  -- Alignment
  -- For every nearby boid in the system, calculate the average velocity
  def align (boids: [BoidData]) : Vector2D {
    let neighbordist = 50;
    let sum = new Vector2D(0.0, 0.0);
    let count = 0;
    for other in boids {
      let d = sum.distance(other.location);
      if ((d > 0) and (d < neighbordist)) then {
        sum.add(other.velocity);
        count = count + 1;
      };

      if (count > 0) then {
        sum.div(count*1.0);
        --First two lines of code below could be condensed with new PVector setMag() method
        --Not using this method until Processing.js catches up
        --sum.setMag(maxspeed);

        --// Implement Reynolds: Steering = Desired - Velocity
        sum.normalize();
        sum.mul(this.data.maxspeed);

        let steer = sum.sub(this.data.velocity);
        steer.limit(this.data.maxforce);
        steer
      }
      else {
        new Vector2D(0.0, 0.0);
      }
    }
  }

  def cohesion(boids: [BoidData]) : Vector2D {
    let neighborDistance = 50.0;
    let location = this.data.location;
    let sum = new Vector2D(0.0, 0.0);
    let count = 0;
    for other in boids {
      let d = location.distance(other.location);
      if (d > 0) and (d < neighborDistance) then {
        sum.add(other.location);
        count = count + 1;
      }
    };
    if (count > 0) then {
      sum.div(count);
      this.seek(sum);
    } else {
      new Vector2D(0, 0);
    }
  }
}
